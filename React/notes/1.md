# React.js Frequently Asked Questions

# Table of Contents

- [What is React?](#what-is-react)
- [Explain the difference between Real DOM, Virtual DOM, and Shadow DOM?](#)
- [What are the key features of React?](#)
- [What is JSX?](#)
- [Why can't browsers read JSX?]()
- [What are React components?]()
- [Differentiate between a Class component and a Functional component.]()
- [What is the difference between state and props in React?]()
- [What are React hooks? Name some common hooks.]()
- [How do useState and useEffect work in React?]()
- [What is the importance of key in React?]()
- [Explain the concept of lifting state up in React.]()
- [How does one pass data between components in React?]()
- [What are the new features introduced in React 18?]()
- [What is concurrent rendering in React 18?]()
- [How does automatic batching work in React 18?]()
- [What is useTransition hook, and how does it work?]()
- [Explain the working of useDeferredValue in React 18.]()
- [What is Suspense in React, and how does it work?]()
- [How has React 18 improved Suspense?]()
- [What is the new startTransition function in React 18?]()
- [What is the difference between useTransition and startTransition?]()
- [How do you use the Concurrent Features introduced in React 18?]()
- [How does React 18 enhance server-side rendering (SSR)?]()
- [What is React Server Components, and how does it work with React 18?]()
- [What role does the concurrentMode flag play in React 18?]()
- [Explain the React lifecycle methods in detail.]()
- [What is React Context API, and when would you use it?]()
- [What are higher-order components (HOCs) in React?]()
- [How does React handle forms and controlled components?]()
- [What are uncontrolled components in React?]()
- [What is Prop Drilling, and how can it be avoided?]()
- [What are React Portals, and when should you use them?]()
- [What is the significance of React’s shouldComponentUpdate method?]()
- [What are Fragments in React?]()
- [Explain the concept of memoization in React using React.memo and useMemo.]()
- [How Do You Optimize Performance in a React Application?]()
- [Rules for Using React Hooks]()
- [Handling Errors in React Using Error Boundaries]()
- [componentDidCatch Method]()
- [Synthetic Events in React]()
- [Testing React Components]()
- [Role of Jest in React Testing]()
- [Shallow Rendering vs. Full Rendering]()
- [Implementing Lazy Loading in React]()
- [What are PropTypes in React?]()
- [What is Redux, and how is it used in React?]()
- [What is the difference between Context API and Redux?]()
- [How do you handle side effects in Redux?]()
- [How do you handle side effects in Redux?]()
- [What is the difference between React.memo and useMemo?]()
- [What is the difference between useCallback and useMemo?]()
- [What is React Fiber?]()
- [How does hydration work in React?]()
- [What are static methods in React components?]()
- [What are the best practices for structuring a React application?]()
- [What is the difference between useEffect and useLayoutEffect?]()
- [How does React handle updates to child components?]()
- [What is StrictMode in React?]()
- [How do you create a reusable modal in React?]()
- [How does React handle accessibility?]()
- [What is a render prop in React?]()
- [How does React handle animations?]()
- [What is the useImperativeHandle hook?]()
- [What is the difference between React.createElement and JSX?]()
- [What is reconciliation in React?]()
- [What is the difference between useRef and createRef?]()
- [What are default props in React?]()
- [What are controlled and uncontrolled inputs in forms?]()
- [What is the key prop in React, and why is it important?]()
- [What is the difference between React.Fragment and <></>?]()
- [What are React's new features in React 19?]()
- [What is the difference between useMemo and React.memo?]()
- [How does the React working mechanism function?]()
- [Implement Custom React "classnames" Library]()
- [Implement Custom Redux using "immer" Library]()
- [Implement Custom Virtual DOM - Serialization]()
- [Implement Custom Virtual DOM - Deserialization]()
- [Memoize/Cache Identical API Calls]()
- [Setting up Redux/Redux Toolkit in React]()
- [Setting up Routing and Private Routing in React]()
- [How to Do Jest Setup in a React Project]()
- [Create Some Commonly Used React Custom Hooks with Examples]()
- [What is reducer, action, store in redux]()
- [What is middleware in Redux]()
- [Explain data flow in Redux]()
- [What is Redux-Thunk]()
- [What is Redux-Saga, Defference between Redux-Thunk and Redux-Saga]()
- [How can we impliment componentWillUnmount in function component]()
- [What is difference between export default and export in React js]()
- [What is Portal in React JS]()
- [What is useRef in React JS]()
- [What is server side render in React JS]()
- [What is useStrict in React JS]()
- [What is node module in React JS]()
- [What is super, constructor, render function in React JS]()

# 1. What is React?

**React** is a JavaScript library for building user interfaces. It enables developers to create reusable UI components and efficiently update and render components in response to data changes.

React is a JavaScript library for building user interfaces, developed and maintained by Meta (formerly Facebook). It is primarily used for building single-page applications (SPAs), where data dynamically changes over time without requiring a full page reload.

React promotes a component-based architecture, where the UI is broken down into small, reusable, and self-contained pieces.

### React Working Mechanism – Behind the Scenes

### Overview

React is a declarative, component-based JavaScript library used to build efficient and interactive user interfaces. While developers typically work with React at the component and hook level, it internally follows a well-defined set of steps and algorithms to convert UI declarations into real DOM updates.

This document provides a deep-dive explanation of how React works behind the scenes, including the **rendering lifecycle**, **reconciliation**, and **diffing algorithm**.

---

## 1. React's Rendering Lifecycle

React follows a **two-phase rendering process**:

### **1. Render Phase (Pure/Read-Only Phase)**

- React **calls the component functions** to generate the Virtual DOM (a lightweight JavaScript representation of the UI).
- It builds a **React Fiber tree** representing the UI structure.
- This phase is **pure** and **side-effect-free**.

### **2. Commit Phase (Impure/DOM Mutation Phase)**

- React **compares the new Fiber tree to the previous one** to calculate changes.
- It updates the real DOM in the most efficient way possible.
- React also executes side-effects (e.g., `useEffect`, `componentDidMount`).

---

## 2. The Virtual DOM

- The **Virtual DOM (VDOM)** is a JavaScript object tree that mimics the real DOM.
- Every time the state or props change, React re-renders the component and creates a new VDOM tree.
- React then compares the **new VDOM** with the **previous VDOM** using a process called **reconciliation**.

---

## 3. Reconciliation

Reconciliation is React's process of updating the DOM when state or props change.

### Steps:

1. Create a new React element tree from updated components.
2. Compare it with the old tree (using the diffing algorithm).
3. Calculate the **minimum number of operations** needed to update the real DOM.
4. Apply these operations in the **commit phase**.

React aims to make this process as fast as possible using **heuristics and assumptions**.

---

## 4. The Diffing Algorithm

React uses a highly optimized **O(n)** algorithm to compare trees.

### Key Assumptions:

1. Elements of different types produce different trees.
2. Developers can hint identity via `key` props in lists.

### Types of Comparisons:

- **Element Type Change**: Replace the node entirely.
- **Props Change**: Update only the changed attributes.
- **Children List Change**: Uses keys to reorder, insert, or remove nodes efficiently.

```jsx
<ul>
  {items.map((item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
```

> Using unique `key` props helps React optimize list diffs.

---

## 5. React Fiber Architecture

Fiber is the **underlying data structure** used by React (since v16) to manage rendering.

### Fiber Benefits:

- Enables **incremental rendering** (pause and resume work).
- Handles **prioritization** (e.g., user interactions vs data fetching).
- Supports **concurrent rendering**.

Each unit of work in React is a **Fiber node**, which contains:

- Component type
- Props/state
- Reference to child/sibling/parent fibers
- Effect flags (to track what needs committing)

---

## 6. Concurrent Rendering (React 18+)

React 18 introduces **Concurrent Features** allowing React to work on multiple tasks simultaneously:

- **startTransition()**: Mark updates as non-urgent.
- **useDeferredValue()**: Defer non-critical renders.

### Example:

```jsx
startTransition(() => {
  setSearchQuery(input);
});
```

> React will delay this state update if more important work is pending.

---

## 7. Lifecycle of a Component (Functional with Hooks)

| Lifecycle Stage   | Hook Equivalent                                  |
| ----------------- | ------------------------------------------------ |
| Component Mount   | `useEffect(() => {}, [])`                        |
| Component Update  | `useEffect(() => {...}, [deps])`                 |
| Component Unmount | `useEffect(() => {... return () => {...} }, [])` |

---

## Summary Table

| Concept           | Description                                       |
| ----------------- | ------------------------------------------------- |
| Virtual DOM       | In-memory representation of UI                    |
| Fiber             | Core data structure that tracks components & work |
| Reconciliation    | The process of diffing and applying UI changes    |
| Diffing Algorithm | Heuristic algorithm for comparing VDOM trees      |
| Concurrent Mode   | Allows React to work on tasks asynchronously      |

---

## Conclusion

React's internal mechanisms are built for performance, responsiveness, and scalability. By understanding how Virtual DOM, Fiber, reconciliation, and the diffing algorithm work, senior developers can write more performant applications and debug complex UI behaviors effectively.

> Mastering React internals equips you to optimize rendering, improve UX, and architect high-performing apps with confidence.

---

[🔝 Back to Top](#table-of-contents)

## 2. Explain the difference between Real DOM and Virtual DOM?

Understanding the difference between **Real DOM** and **Virtual DOM** is fundamental for optimizing and reasoning about how React performs updates and improves performance.

## 🧱 What is the Real DOM?

The **Real DOM (Document Object Model)** is the browser’s live, structured representation of the HTML document. It is a tree-like structure where each HTML element is a node.

### Characteristics:

- **Directly represents the UI**.
- **Heavyweight and slow** to update.
- Re-rendering the DOM involves **layout recalculations and reflows**, which can be expensive.
- **Every update** results in **a new DOM tree being created**, and the affected parts of the UI are re-rendered, even if only a small part changed.

### Example:

```html
<div id="root">
  <h1>Hello, World!</h1>
</div>
```

When JavaScript modifies the DOM directly:

```js
const heading = document.querySelector("h1");
heading.textContent = "Updated Text";
```

This operation triggers a layout recalculation and potentially repaints.

---

## ⚛️ What is the Virtual DOM?

The **Virtual DOM (VDOM)** is a **lightweight, in-memory representation** of the Real DOM used by React and other libraries to efficiently manage UI updates.

### Characteristics:

- **Not tied to the browser** – it’s just a JavaScript object tree.
- React creates a new Virtual DOM tree on every render.
- React uses a **diffing algorithm** to compare the new Virtual DOM with the previous one.
- Only the **minimal set of changes** is applied to the Real DOM.

### Example:

```jsx
const element = <h1>Hello, World!</h1>;
ReactDOM.render(element, document.getElementById("root"));
```

React tracks changes in the VDOM and updates only what’s necessary.

---

## 🔄 Update Flow Comparison

| Feature             | Real DOM                          | Virtual DOM                                                   |
| ------------------- | --------------------------------- | ------------------------------------------------------------- |
| Update Speed        | Slower (direct manipulation)      | Faster (batch updates)                                        |
| Efficiency          | Inefficient for frequent updates  | Highly optimized                                              |
| Re-rendering        | Updates entire UI tree or subtree | Calculates diff and patches minimal changes                   |
| Platform Dependence | Browser-based                     | Abstract layer (can be rendered to web, native, or elsewhere) |
| Programming Model   | Imperative                        | Declarative                                                   |

---

## 🎯 Why Virtual DOM Matters in React

React's performance advantage stems from:

1. **Batching multiple changes** before applying them.
2. **Reconciliation**: React uses a **diffing algorithm** to identify what actually changed.
3. **Efficient DOM updates**: Only changed nodes are updated in the Real DOM.

---

## 🚀 Real-World Analogy

- **Real DOM**: Like redrawing an entire painting for a small change.
- **Virtual DOM**: Like sketching the change on a draft paper, comparing it to the original, and then applying just that small fix to the final artwork.

---

## 🧠 Summary

| Concept       | Real DOM                               | Virtual DOM                             |
| ------------- | -------------------------------------- | --------------------------------------- |
| Performance   | Slower updates                         | Faster updates with diffing             |
| Complexity    | Simple but inefficient for dynamic UIs | Abstract, but optimized for dynamic UIs |
| Usage         | Native to the browser                  | Introduced by libraries like React      |
| Mutation Cost | High                                   | Low due to reconciliation               |

The **Virtual DOM** is a core innovation that powers React’s efficient rendering model, making it a powerful abstraction for building high-performance UIs.

> 💡 As a senior React developer, understanding how VDOM improves over Real DOM helps in writing better-performing components and optimizing rendering strategies.

---

# 3. What are the key features of React?

1. **Virtual DOM** for efficient rendering.
2. **Component-based Architecture**.
3. **Declarative UI**.
4. **Unidirectional Data Flow**.
5. **JSX Syntax**.
6. **React Hooks** for functional components.
7. **Server-side Rendering (SSR)**.
8. **React Developer Tools**.

React is a popular JavaScript library for building dynamic and performant user interfaces. Its architecture and design enable scalable, component-driven development. Below are the **key features** that make React a powerful tool for frontend development:

---

## 🔹 1. Component-Based Architecture

React breaks the UI into **independent, reusable pieces** called components.

```jsx
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}
```

- Encourages **modularity and reusability**.
- Each component can manage its own **state and lifecycle**.

---

## 🔹 2. Virtual DOM

React uses a **Virtual DOM**, a lightweight in-memory representation of the real DOM.

- Improves performance through **efficient diffing and minimal updates**.
- Enables **high-speed UI rendering** by reducing expensive real DOM operations.

---

## 🔹 3. Declarative UI

React enables you to describe what the UI should look like **based on the state**.

```jsx
const App = ({ isLoggedIn }) => (
  <div>{isLoggedIn ? "Welcome!" : "Please sign in."}</div>
);
```

- Makes the code **more predictable** and easier to debug.
- React handles **updating the DOM** to match your data.

---

## 🔹 4. JSX (JavaScript XML)

JSX is a syntax extension for JavaScript that allows writing **HTML-like code** within JavaScript.

```jsx
const element = <h1>Hello, world!</h1>;
```

- Makes UI structure **more readable and expressive**.
- Transpiled using Babel to `React.createElement()` calls.

---

## 🔹 5. Hooks API

Introduced in React 16.8, **Hooks** allow using state and lifecycle features in **functional components**.

- `useState`, `useEffect`, `useContext`, `useMemo`, `useCallback`

```jsx
const [count, setCount] = useState(0);
```

- Promotes **cleaner code** and better separation of concerns.

---

## 🔹 6. Unidirectional Data Flow

Data in React flows in **one direction** (from parent to child) via **props**.

- Encourages **predictable data models**.
- Easier to **debug and maintain** large applications.

---

## 🔹 7. Lifecycle Methods

For class components, React provides lifecycle methods like:

- `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`

In functional components, lifecycle-like behavior is handled via `useEffect()`.

---

## 🔹 8. React Developer Tools

A powerful set of browser extensions to inspect:

- Component hierarchy
- Props and state
- React performance profiling

---

## 🔹 9. Context API

Provides a way to **share global data** like theme, user info, or language across components **without prop drilling**.

```jsx
const ThemeContext = React.createContext("light");
```

---

## 🔹 10. Server-Side Rendering (SSR) Support

Using frameworks like **Next.js**, React supports rendering components **on the server**.

- Improves SEO
- Reduces time-to-first-byte (TTFB)

---

## 🔹 11. Concurrent Rendering (via Fiber Architecture)

React’s **Fiber architecture** enables features like:

- **Time-slicing**: breaking rendering into units of work
- **Suspense**: asynchronous rendering for lazy-loaded components

---

## 🔹 12. Rich Ecosystem and Community

React has a vast collection of:

- Component libraries (Material UI, Chakra UI, etc.)
- State management tools (Redux, Zustand, Recoil)
- Routing solutions (React Router)

---

## 🔹 13. Portability with React Native

React enables building **native mobile applications** using **React Native** with the same core concepts.

- Code reuse between web and mobile
- Single development paradigm

---

## ✅ Summary Table

| Feature              | Description                                         |
| -------------------- | --------------------------------------------------- |
| Component-Based      | Reusable, self-contained UI building blocks         |
| Virtual DOM          | Efficient UI updates with diffing algorithm         |
| Declarative Syntax   | UI reflects state                                   |
| JSX                  | HTML in JS, enhanced readability                    |
| Hooks                | Functional components with state/lifecycle support  |
| One-Way Data Binding | Predictable and controlled data flow                |
| Context API          | Global state sharing without prop drilling          |
| SSR Support          | SEO-friendly rendering with tools like Next.js      |
| Developer Tools      | Rich debugging and inspection support               |
| React Native         | Build native mobile apps using React components     |
| Concurrent Mode      | Asynchronous rendering and performance optimization |

---

These features combined make React a powerful, flexible, and high-performance solution for building complex and modern web applications.

---

## 4. What is JSX?

**JSX (JavaScript XML)** is a **syntax extension for JavaScript** commonly used with **React** to describe what the UI should look like. JSX allows developers to write **HTML-like markup** directly within JavaScript code.

JSX gets transpiled (usually by **Babel**) into standard `React.createElement()` calls which the browser can interpret.

---

## Why Use JSX?

- Improves **readability** and **developer productivity** by allowing a declarative UI syntax.
- Embeds component logic and layout together.
- Offers **syntax familiar to HTML/CSS developers**, reducing the learning curve.
- Helps **leverage the full power of JavaScript** within templates.

---

## JSX Example

```jsx
const name = "Alice";
const greeting = <h1>Hello, {name}!</h1>;
```

This is transpiled to:

```js
const greeting = React.createElement("h1", null, `Hello, ${name}!`);
```

---

## Embedding Expressions

You can embed any JavaScript expression inside JSX by wrapping it in curly braces `{}`.

```jsx
const user = { firstName: "John", lastName: "Doe" };
const element = <p>{user.firstName + " " + user.lastName}</p>;
```

---

## JSX is Not a Template Engine

- Unlike traditional templating engines (like Handlebars or EJS), JSX is **closer to JavaScript** than HTML.
- It supports **if/else logic, loops, functions**, and other JS features natively.

### Example: Conditional Rendering

```jsx
const element = isLoggedIn ? <Dashboard /> : <LoginForm />;
```

---

## JSX Rules

### 1. Single Parent Element

All JSX elements must have **one parent element**.

```jsx
return (
  <div>
    <h1>Title</h1>
    <p>Description</p>
  </div>
);
```

### 2. Self-Closing Tags

Tags without children must be **self-closed**:

```jsx
<img src='avatar.png' alt='Avatar' />
```

### 3. `className` instead of `class`

`class` is a reserved keyword in JS, so JSX uses `className`.

```jsx
<div className='container'></div>
```

### 4. `htmlFor` instead of `for`

```jsx
<label htmlFor='email'>Email</label>
```

---

## Using JavaScript in JSX

You can call functions, use array methods, and perform inline calculations.

```jsx
<ul>
  {items.map((item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
```

---

## JSX Best Practices

- **Keep JSX clean**: Use smaller, readable components.
- **Use keys** when rendering lists.
- **Avoid complex logic** inside JSX — move to helper functions if needed.
- **Use fragments** (`<>...</>`) to group multiple elements without extra divs.

```jsx
return (
  <>
    <Header />
    <Content />
    <Footer />
  </>
);
```

---

## JSX in the Build Process

- JSX is **not valid JavaScript**. Tools like **Babel** transform JSX into JavaScript during the build process.
- You need a build system like **Webpack** (often used with Create React App or Vite).

---

## Common Interview Points

| Topic                 | Details                                         |
| --------------------- | ----------------------------------------------- |
| JSX vs HTML           | JSX uses `className`, `htmlFor`, etc.           |
| JSX Compilation       | Transpiles to `React.createElement()`           |
| Logic in JSX          | Can use JS expressions but not statements       |
| Fragment Usage        | Prevent unnecessary DOM nodes                   |
| Conditional Rendering | Via ternary or short-circuiting                 |
| Reusability           | JSX makes it easy to create and reuse UI blocks |

---

## Summary

JSX is a **powerful abstraction** that blends the **declarative clarity of HTML** with the **power and flexibility of JavaScript**. It enhances React's developer experience by making component-based UI logic more expressive, readable, and maintainable.

Understanding JSX deeply is fundamental for any senior React developer.

---

---

# 5. Why can't browsers read JSX?

**JSX (JavaScript XML)** is a syntax extension for JavaScript used in React to describe UI components in an HTML-like syntax. While JSX looks like HTML, **browsers cannot interpret JSX directly**.

---

## Why Browsers Can’t Read JSX

### 1. **JSX is Not Valid JavaScript**

JSX is a **syntactic sugar** built on top of JavaScript. Browsers have JavaScript engines that can only interpret **valid ECMAScript** (standard JS). JSX contains **non-standard syntax**, which must be transpiled.

#### Example:

```jsx
const element = <h1>Hello, world!</h1>;
```

This line is **not valid JavaScript** — the browser would throw a syntax error.

---

## How JSX Works Behind the Scenes

### JSX Transpilation

JSX must be converted into standard JavaScript before it can run in the browser. This is handled by **transpilers** like **Babel**.

#### Transpiled Version:

```js
const element = React.createElement("h1", null, "Hello, world!");
```

This version is valid JavaScript and can be executed by the browser’s JS engine.

---

## Tooling to Handle JSX

- **Babel**: Converts JSX into `React.createElement()` calls.
- **Webpack/Vite/Parcel**: Bundlers that integrate Babel and package the application.
- **Create React App (CRA)**: Provides out-of-the-box JSX support with build configuration.

### Configuration Example (babel.config.js)

```js
module.exports = {
  presets: ["@babel/preset-env", "@babel/preset-react"],
};
```

---

## What Happens at Runtime

1. You write JSX.
2. Babel transpiles JSX to JavaScript.
3. Webpack/Vite bundles the code.
4. The browser receives the transpiled JS.
5. React creates and manipulates DOM nodes using `React.createElement()` under the hood.

---

## Summary Table

| Concept              | JSX              | JavaScript (Browser Compatible)            |
| -------------------- | ---------------- | ------------------------------------------ |
| Example              | `<h1>Hello</h1>` | `React.createElement('h1', null, 'Hello')` |
| Can browsers run it? | ❌ No            | ✅ Yes                                     |
| Needs transpilation  | ✅ Yes           | ❌ No                                      |

---

## Key Takeaways

- **Browsers cannot read JSX directly** because it's not part of the ECMAScript standard.
- JSX must be **transpiled into valid JavaScript** using Babel.
- This step happens during **build time**, not runtime.
- Understanding the JSX-to-JS transformation is critical for senior-level debugging and optimization.

---

## Interview Tip

If asked why JSX doesn’t work in browsers, explain:

> "JSX is a developer-friendly syntax that resembles HTML but is not valid JavaScript. Therefore, browsers can’t parse it natively. Tools like Babel convert it into plain JavaScript before it's executed in the browser."

This shows not just familiarity with React, but an understanding of the build and execution pipeline.

---

---

## 6. What are React components?

React components are the **fundamental building blocks** of any React application. They encapsulate UI pieces and logic, allowing you to create **modular, reusable, and maintainable code**.

---

## Key Characteristics of React Components

- **Reusable**: Define once, use anywhere.
- **Compositional**: Build complex UIs from smaller parts.
- **Declarative**: Describe how the UI should look for a given state.
- **Encapsulated**: Each component manages its own state and behavior.

---

## Types of Components

### 1. **Functional Components** (Recommended)

These are JavaScript functions that accept props and return JSX.

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

#### Modern Usage with Hooks:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

### 2. **Class Components** (Legacy)

Use ES6 classes and provide lifecycle methods.

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

> 📌 **Note**: Functional components with Hooks are the modern standard since React 16.8.

---

## Component Composition

React encourages building UIs by nesting components:

```jsx
function App() {
  return (
    <div>
      <Header />
      <Main />
      <Footer />
    </div>
  );
}
```

---

## Props: Passing Data to Components

Props are read-only inputs to components.

```jsx
function Greet({ name }) {
  return <h2>Hello, {name}</h2>;
}

<Greet name='Alice' />;
```

---

## State: Local Data within Components

State allows components to create and manage internal data.

```jsx
const [isOn, setIsOn] = useState(true);
```

---

## Lifecycle (Class) vs Hooks (Function)

| Lifecycle Method     | Hook Equivalent     |
| -------------------- | ------------------- |
| componentDidMount    | useEffect           |
| componentDidUpdate   | useEffect           |
| componentWillUnmount | useEffect (cleanup) |

---

## Best Practices

- Keep components small and focused.
- Use props for configuration.
- Avoid complex logic inside render.
- Separate stateful and stateless components when possible.
- Use memoization (`React.memo`, `useMemo`, `useCallback`) to optimize rendering.

---

## Conclusion

React components are the **core unit of abstraction** in React. Mastery over component design, props, state management, and hooks is essential for building scalable and performant applications.

In interviews, demonstrate:

- When to use components.
- How to design reusable components.
- Differences between function and class components.
- Component communication using props and context.

> 🎯 A senior developer is expected to not only use components but design them for extensibility, testability, and clarity.

---

---

## 7. Differentiate between a Class component and a Functional component.

In React, components can be created using **classes** or **functions**. Understanding the distinction is crucial, especially when discussing performance, hooks, lifecycle methods, and current best practices in modern React development.

---

### Class Component

A component defined using an ES6 class. It extends `React.Component` and must contain a `render()` method.

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

### Functional Component

A plain JavaScript function that returns JSX.

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

---

## 2. Syntax Simplicity

| Feature   | Class Component               | Functional Component |
| --------- | ----------------------------- | -------------------- |
| Syntax    | Verbose (class, `this`)       | Concise and readable |
| State     | `this.state`, `this.setState` | `useState()` hook    |
| Lifecycle | Class methods                 | `useEffect()` hook   |
| Binding   | Manual `this` binding needed  | No `this` required   |

---

## 3. State and Side Effects

### Class Component Example:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => this.setState({ count: this.state.count + 1 });

  render() {
    return <button onClick={this.increment}>{this.state.count}</button>;
  }
}
```

### Functional Component with Hooks:

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

## 4. Lifecycle Methods

### Class Component:

- `componentDidMount()`
- `componentDidUpdate()`
- `componentWillUnmount()`

### Functional Component:

All managed through `useEffect()`:

```jsx
useEffect(() => {
  // componentDidMount + componentDidUpdate
  return () => {
    // componentWillUnmount
  };
}, [dependencies]);
```

---

## 5. Performance & Modern Best Practices

- Functional components are generally preferred today.
- Easier to read, test, and maintain.
- Work seamlessly with React features like **Hooks**, **Concurrent Mode**, and **Suspense**.

---

## 6. When to Use What?

| Use Case                             | Recommendation                  |
| ------------------------------------ | ------------------------------- |
| Modern React applications            | Functional Components           |
| Using React Hooks                    | Functional Components           |
| Legacy code or lifecycle granularity | Class Components (rarely today) |

---

## Conclusion

Functional components, enhanced with Hooks, have largely replaced class components in modern React development. However, understanding both is essential for maintaining older codebases and demonstrating well-rounded knowledge in interviews.

> 🎯 As a senior developer, knowing **why** functional components are favored and **how** React handles them internally can set you apart in technical interviews.

---

---

## 8. What is the difference between state and props in React?

React uses both **state** and **props** to manage data and control component behavior, but they serve different purposes:

#### 1. **Definition**

- **Props** (short for "properties"):

  - Read-only data passed from a parent component to a child component.
  - Immutable from the child component's perspective.
  - Used to configure or customize a component.

- **State**:
  - A data structure that starts with a default value when a component mounts.
  - Can be changed over time, typically in response to user actions or other events.
  - Managed within the component itself (or using hooks like `useState`).

---

#### 2. **Mutability**

- **Props**: Immutable – child components cannot change them.
- **State**: Mutable – managed and updated using `setState` (class components) or `useState` (functional components).

---

#### 3. **Usage Context**

- **Props**:

  - Ideal for passing data from parent to child.
  - Used to render dynamic content based on external input.

- **State**:
  - Used for data that changes over time (e.g., input field values, toggles, etc.).
  - Suitable for local component behavior.

---

#### 4. **Example**

```jsx
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}

function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

- `Greeting` uses **props** to receive `name`.
- `Counter` uses **state** to keep track of the number of clicks.

---

#### 5. **Summary Table**

| Feature                 | Props                      | State                          |
| ----------------------- | -------------------------- | ------------------------------ |
| Mutability              | Immutable                  | Mutable                        |
| Ownership               | Parent Component           | Own Component                  |
| Purpose                 | Pass data & configuration  | Manage internal data           |
| Updates Cause Re-render | Yes                        | Yes                            |
| Accessible From         | Child components via props | Within the component via hooks |

---

Understanding the difference between props and state is fundamental to mastering React component design and data flow.

---

---

## 9. What are React hooks? Name some common hooks.

React Hooks are special functions introduced in React 16.8 that allow developers to use state and other React features in functional components, without writing class components.

Hooks provide a more direct API to React concepts such as state, lifecycle, context, and refs, making code easier to understand and test.

### Why Hooks?

Simplify component logic reuse.

Eliminate the need for classes.

Better separation of concerns in complex components.

Encourage function component usage.

**Common hooks:**

### 1. `useState`

Allows functional components to have local state.

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>Clicked {count} times</button>
  );
}
```

### 2. `useEffect`

Used for side effects like data fetching or subscriptions.

```jsx
import React, { useEffect, useState } from "react";

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("https://api.example.com/data")
      .then((response) => response.json())
      .then((data) => setData(data));
  }, []); // Empty dependency array means it runs only once.

  return <div>{data ? JSON.stringify(data) : "Loading..."}</div>;
}
```

### 3. `useContext`

Access context values without wrapping components in a Consumer.

```jsx
import React, { useContext, createContext } from "react";

const ThemeContext = createContext("light");

function ThemeButton() {
  const theme = useContext(ThemeContext);
  return <button>{theme} Theme</button>;
}
```

### 4. `useReducer`

Manages complex state logic.

```jsx
import React, { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <span>{state.count}</span>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
    </div>
  );
}
```

### 5. `useRef`

Access DOM elements or persist values without causing re-renders.

```jsx
import React, { useRef } from "react";

function InputFocus() {
  const inputRef = useRef(null);

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Focus</button>
    </div>
  );
}
```

### 6. `useMemo`

Memoize expensive calculations.

```jsx
import React, { useMemo, useState } from "react";

function ExpensiveComponent({ num }) {
  const compute = (num) => {
    let result = 0;
    for (let i = 0; i < 1000000000; i++) result += num;
    return result;
  };

  const result = useMemo(() => compute(num), [num]);

  return <div>Result: {result}</div>;
}
```

---

---

## 10. How do `useState` and `useEffect` work in React?

React's `useState` and `useEffect` hooks are two of the most essential tools for managing component state and side effects in functional components.

---

### `useState`

#### Purpose

- Adds local state to functional components.
- Returns a stateful value and a function to update it.

#### Syntax

```jsx
const [state, setState] = useState(initialValue);
```

#### Example

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

#### Key Points

- `useState` initializes with the `initialValue`.
- Updating state with `setState` triggers a re-render.
- Each call to `useState` is isolated.

---

### `useEffect`

#### Purpose

- Handles side effects like fetching data, subscriptions, or manually updating the DOM.
- Replaces lifecycle methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.

#### Syntax

```jsx
useEffect(() => {
  // effect logic
  return () => {
    // optional cleanup
  };
}, [dependencies]);
```

#### Example

```jsx
import { useState, useEffect } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds((prev) => prev + 1);
    }, 1000);

    return () => clearInterval(interval); // Cleanup
  }, []); // Empty dependency array => run once on mount

  return <p>Seconds passed: {seconds}</p>;
}
```

#### Key Points

- Runs after render by default.
- Cleanup function is useful for clearing timers, listeners, or subscriptions.
- Dependency array controls when the effect runs:
  - `[]`: runs once on mount
  - `[value]`: runs on mount and when `value` changes

---

### Summary Table

| Hook      | Purpose                            | Example Use Cases                        |
| --------- | ---------------------------------- | ---------------------------------------- |
| useState  | Manage local state                 | Form inputs, toggles, counters           |
| useEffect | Perform side effects in components | Fetch data, set up subscriptions, timers |

---

These two hooks form the foundation of interactive and dynamic functional components in modern React.

---

---

## 11. What is the importance of `key` in React?

In React, the `key` prop is a **special attribute** that must be included when creating **lists of elements**. Keys help React **identify which items have changed, been added, or removed**, enabling efficient updates to the DOM.

---

### Why is `key` Important?

1. **Efficient Re-rendering**

   - React uses keys to optimize rendering performance.
   - Keys help React quickly determine if a DOM element can be reused.

2. **Avoiding Unnecessary DOM Operations**

   - Without a proper key, React may re-render or re-create elements unnecessarily.

3. **Maintaining Component State**
   - Keys help React preserve component state between renders.

---

### Example Without Key (Incorrect)

```jsx
{
  items.map((item) => <li>{item.name}</li>);
}
```

This will trigger a warning in the console because `key` is missing.

### Example With Key (Correct)

```jsx
{
  items.map((item) => <li key={item.id}>{item.name}</li>);
}
```

Using a unique identifier (like `item.id`) as the key ensures proper re-rendering behavior.

---

### Best Practices

- Use **unique, stable identifiers** (e.g., `id`) as keys.
- Avoid using **array indexes** as keys, especially if the list can change.
- Keys must be **unique among siblings** but do not need to be globally unique.

---

### Common Pitfall: Using Index as Key

```jsx
{
  items.map((item, index) => <li key={index}>{item.name}</li>);
}
```

- This can cause issues if items are reordered, added, or removed.
- React may not re-render the list as expected, causing bugs.

---

### Summary Table

| Key Usage     | Behavior                                       |
| ------------- | ---------------------------------------------- |
| Unique ID key | ✅ Optimal and predictable                     |
| Index as key  | ⚠️ Potentially buggy during reorder/add/remove |
| Missing key   | ❌ React warning and inefficient rendering     |

---

The `key` prop is vital for list rendering and performance optimization in React. Choosing the right key improves user experience and reduces rendering bugs.

---

---

## 12. Explain the concept of lifting state up in React.

### What is Lifting State Up in React?

**Lifting state up** is a React pattern where **state is moved to the closest common ancestor** of components that need to share or synchronize that state.

---

### Why Lift State Up?

- To enable **data sharing** between sibling components.
- To **avoid duplicate state** in multiple components.
- To maintain a **single source of truth**.

---

### Example Scenario

Imagine you have two components: `TemperatureInput` and `BoilingVerdict`, and both need access to the temperature value.

#### Before Lifting State (Separate State in Each Component)

```jsx
function TemperatureInput() {
  const [temperature, setTemperature] = useState("");
  return (
    <input
      value={temperature}
      onChange={(e) => setTemperature(e.target.value)}
    />
  );
}

function BoilingVerdict({ temperature }) {
  return <p>{temperature >= 100 ? "Boiling" : "Not Boiling"}</p>;
}
```

This won't work as intended since the state is local to `TemperatureInput`.

#### After Lifting State

```jsx
function Calculator() {
  const [temperature, setTemperature] = useState("");

  return (
    <div>
      <TemperatureInput
        temperature={temperature}
        onTemperatureChange={setTemperature}
      />
      <BoilingVerdict temperature={parseFloat(temperature)} />
    </div>
  );
}

function TemperatureInput({ temperature, onTemperatureChange }) {
  return (
    <input
      value={temperature}
      onChange={(e) => onTemperatureChange(e.target.value)}
    />
  );
}
```

Now both child components share the same state, lifted to the `Calculator` parent.

---

### Best Practices

- Lift state only when **multiple components need to share it**.
- Ensure that **state management remains simple** and not overly centralized.
- Consider **state management libraries** like Redux or Context API for complex state-sharing scenarios.

---

### Summary Table

| Situation                            | Action                      |
| ------------------------------------ | --------------------------- |
| Multiple components need same data   | Lift state to common parent |
| State required in only one component | Keep local                  |
| Deeply nested state sharing          | Consider Context API        |

---

**Lifting state up** is essential in building well-structured React apps that promote data flow clarity and reduce redundant or conflicting state.

---

---

## 13. How does one pass data between components in React?

### How to Pass Data Between Components in React

In React, data typically flows **from parent to child** using **props**, but there are multiple ways to share data between components depending on their relationship.

---

### 1. Parent to Child (Using Props)

This is the most common method.

```jsx
function Parent() {
  return <Child message='Hello from parent!' />;
}

function Child({ message }) {
  return <p>{message}</p>;
}
```

---

### 2. Child to Parent (Using Callback Functions)

The parent passes a function as a prop, and the child calls it to send data back.

```jsx
function Parent() {
  const handleData = (data) => {
    console.log("Received:", data);
  };
  return <Child sendData={handleData} />;
}

function Child({ sendData }) {
  return <button onClick={() => sendData("Hello parent")}>Send</button>;
}
```

---

### 3. Sibling to Sibling (Via Lifting State Up)

Lift the shared state to their common ancestor and pass it as props.

```jsx
function Parent() {
  const [message, setMessage] = useState("");
  return (
    <>
      <Sibling1 setMessage={setMessage} />
      <Sibling2 message={message} />
    </>
  );
}
```

---

### 4. Unrelated Components (Using Context API)

For components that do not share a direct relationship.

```jsx
const MessageContext = createContext();

function App() {
  const [message, setMessage] = useState("");
  return (
    <MessageContext.Provider value={{ message, setMessage }}>
      <ComponentA />
      <ComponentB />
    </MessageContext.Provider>
  );
}

function ComponentA() {
  const { setMessage } = useContext(MessageContext);
  return <button onClick={() => setMessage("From A")}>Set Message</button>;
}

function ComponentB() {
  const { message } = useContext(MessageContext);
  return <p>{message}</p>;
}
```

---

### 5. Global State Management (Redux, Zustand, etc.)

Use when app-scale state management is needed.

```js
// Redux example (simplified)
const state = useSelector((state) => state.someData);
const dispatch = useDispatch();
dispatch(updateData("new data"));
```

---

### Summary Table

| Method                 | Use Case                              |
| ---------------------- | ------------------------------------- |
| Props                  | Parent to child                       |
| Callback Props         | Child to parent                       |
| Lifting State Up       | Sibling communication                 |
| Context API            | Unrelated or deeply nested components |
| Global State Libraries | Complex, app-wide state management    |

---

Understanding how to pass data effectively ensures React apps remain modular, scalable, and maintainable.

---

---

## 14. What are the new features introduced in React 18?

- `useTransition` and `useDeferredValue` hooks.

### New Features Introduced in React 18

React 18 introduced several major features and architectural improvements to enhance performance, concurrency, and user experience.

---

### 1. **Concurrent Rendering (New Architecture)**

- Enables React to interrupt rendering to work on multiple tasks simultaneously.
- Improves responsiveness and paves the way for new APIs.

---

### 2. **Automatic Batching**

- Groups multiple state updates into a single render to improve performance.
- Previously, batching only occurred inside React event handlers.

```jsx
setValue1((v) => v + 1);
setValue2((v) => v + 1); // Both are batched together automatically
```

---

### 3. **Transition API**

- Helps distinguish urgent updates (like typing) from non-urgent ones (like rendering filtered results).

```jsx
const [isPending, startTransition] = useTransition();

startTransition(() => {
  setInputValue(input);
});
```

---

### 4. **Suspense Improvements**

- Better support for asynchronous data loading.
- Can be used for server-side rendering (SSR) with React 18 features.

---

### 5. **useId Hook**

- Generates unique IDs that are consistent between server and client rendering.

```jsx
const id = useId();
```

---

### 6. **Streaming Server-Side Rendering (SSR)**

- Server components stream HTML to the browser while it's being generated.
- Faster initial page load.

---

### 7. **React 18 Root API**

- New root API with support for concurrent features.

```jsx
import { createRoot } from "react-dom/client";
const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

---

### Summary Table

| Feature              | Description                                |
| -------------------- | ------------------------------------------ |
| Concurrent Rendering | Enables interruptible rendering            |
| Automatic Batching   | Groups state updates into one render cycle |
| Transition API       | Marks updates as non-urgent                |
| Improved Suspense    | Better async data support                  |
| useId Hook           | Generates unique IDs for SSR               |
| Streaming SSR        | Sends partial HTML while rendering         |
| New Root API         | Required for enabling concurrent features  |

---

React 18 is designed to be backward compatible and opt-in, so you can gradually adopt the new features without rewriting your application.

---

---

## 15. What is concurrent rendering in React 18?

### What is Concurrent Rendering in React 18?

Concurrent Rendering is a foundational update in React 18 that allows React to prepare multiple versions of the UI at the same time. It enables React to interrupt rendering work and switch to more urgent tasks, resulting in smoother and more responsive user interfaces.

---

### Key Characteristics

- **Interruptible Rendering**: React can pause and resume rendering, or even abandon a render in progress if a higher-priority update comes in.
- **Multiple UI Versions**: React can work on a new screen in the background while keeping the current UI interactive.
- **Improved User Experience**: Reduces blocking, enhances performance for large updates or transitions.

---

### How It Works

React 18 introduces a new root API to enable concurrent features:

```jsx
import { createRoot } from "react-dom/client";

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

This API opt-ins your app to concurrent rendering capabilities.

---

### Real-World Benefit Example

Imagine a user typing in a search bar while a large list of results is rendering. Without concurrency, the UI might freeze until the rendering is complete. With concurrent rendering:

- Typing (high priority) remains responsive.
- List rendering (low priority) can be paused and resumed.

---

### Related APIs

- **`useTransition`**: Mark updates as non-urgent.
- **`startTransition`**: Run transitions in the background.
- **`useDeferredValue`**: Defer re-rendering of non-critical parts of the UI.

---

### Summary Table

| Concept                | Description                                        |
| ---------------------- | -------------------------------------------------- |
| Interruptible UI       | React can pause work to respond to new events      |
| Priority-based Updates | UI remains responsive during heavy rendering tasks |
| New Root API           | Enables concurrent mode for your app               |

---

Concurrent rendering doesn’t change how React works at a high level, but it gives React more control over rendering priorities, which helps deliver faster and more fluid user experiences.

---

---

## 16. How does automatic batching work in React 18?

### How Does Automatic Batching Work in React 18?

Automatic batching is a performance optimization introduced in **React 18** that allows multiple state updates to be grouped into a single render, reducing the number of re-renders and improving app performance.

---

### What Is Batching?

**Batching** is the process of combining multiple state updates into one render pass. React has always batched updates inside event handlers, but React 18 extends this to more situations.

Before React 18:

```jsx
setCount(1);
setFlag(true); // May cause two separate renders outside event handlers
```

In React 18:

```jsx
setCount(1);
setFlag(true); // Automatically batched into a single render
```

---

### Where It Works

Automatic batching now works in:

- `setTimeout`
- `Promise.then`
- Native event handlers
- `useEffect`, `useLayoutEffect`, etc.

Example:

```jsx
fetchData().then(() => {
  setLoading(false);
  setData(response); // Both updates are batched
});
```

---

### opt-out: `flushSync`

If needed, you can opt-out of batching using `flushSync`:

```jsx
import { flushSync } from "react-dom";

flushSync(() => {
  setCount(1);
});
setFlag(true); // Triggers a second render
```

---

### Benefits

- **Improved performance**: Fewer renders for multiple updates.
- **Cleaner code**: No need to manually batch updates.
- **Consistency**: Works across more async scenarios.

---

### Summary Table

| Feature                 | Description                             |
| ----------------------- | --------------------------------------- |
| Automatic Batching      | Groups state updates in one render pass |
| Extended to Async Logic | Works in Promises, setTimeout, etc.     |
| Opt-out Option          | Use `flushSync()` to separate updates   |

---

Automatic batching in React 18 simplifies performance tuning by reducing the overhead of multiple renders and making the rendering process more predictable.

---

---

## 17. What is `useTransition` hook, and how does it work?

The `useTransition` hook, introduced in **React 18**, enables developers to differentiate between **urgent** and **non-urgent** state updates. It allows non-urgent updates (transitions) to be deferred, keeping the UI responsive.

---

### Why Use `useTransition`?

In many apps, some updates are more important (e.g., typing input) while others can be delayed (e.g., updating a long list). `useTransition` helps prioritize updates for better user experience.

---

### Syntax

```jsx
const [isPending, startTransition] = useTransition();
```

- `isPending`: A boolean indicating whether the transition is ongoing.
- `startTransition`: A function to wrap non-urgent updates.

---

### Example

```jsx
const [query, setQuery] = useState("");
const [results, setResults] = useState([]);
const [isPending, startTransition] = useTransition();

const handleInputChange = (e) => {
  const value = e.target.value;
  setQuery(value); // urgent update

  startTransition(() => {
    const filtered = expensiveSearch(value);
    setResults(filtered); // non-urgent update
  });
};
```

### Output Behavior

- UI updates from `setQuery` are immediate.
- `setResults` update might be deferred if React needs to prioritize more urgent rendering.
- `isPending` is `true` while the transition is in progress (e.g., show a loading spinner).

---

### Benefits

- Keeps the app responsive during heavy updates.
- Improves perceived performance.
- Simple to integrate into existing logic.

---

### Summary Table

| Element           | Description                           |
| ----------------- | ------------------------------------- |
| `startTransition` | Marks non-urgent state updates        |
| `isPending`       | Flags if transition is in progress    |
| Main Benefit      | Prevents blocking on heavy operations |

---

The `useTransition` hook is key in enabling smoother user interactions by handling performance-sensitive updates in modern React apps.

---

---

## 18. Explain the working of `useDeferredValue` in React 18.

`useDeferredValue` defers the re-render of non-urgent updates.

**Example:**

```jsx
const deferredValue = useDeferredValue(value);
```

---

---

## 19. What is Suspense in React, and how does it work?

**React Suspense** is a built-in feature introduced by React to **handle asynchronous rendering** in a declarative way. It allows components to **"wait"** for something (like data or code) before they render, providing a **fallback UI** (like a loading spinner) in the meantime.

Originally introduced to support **code-splitting** with `React.lazy()`, Suspense is now increasingly used with **data fetching**, especially alongside libraries like **React Query**, **Relay**, or **React Server Components**.

---

## Basic Use Case – Code Splitting

```jsx
import React, { Suspense, lazy } from "react";

const LazyComponent = lazy(() => import("./MyComponent"));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

### Explanation:

- `lazy()` dynamically imports the component.
- `Suspense` wraps the component and renders the fallback until it finishes loading.

---

## How Suspense Works Behind the Scenes

React introduces a **suspension mechanism**:

- If a component (or a hook it uses) **throws a Promise**, React "suspends" rendering of that component tree.
- React then shows the **fallback** UI (defined in `<Suspense fallback={...}>`) until the promise resolves.
- Once resolved, React **retries rendering** from where it left off.

> This mechanism is key to **Concurrent React**, enabling smooth and interruptible rendering for a responsive UI.

---

## Real-World Usage – Data Fetching (with React 18+)

React now supports Suspense for data fetching through **concurrent rendering** features:

```jsx
function Profile() {
  const user = use(fetchUserData()); // This throws a promise if data is not ready
  return <h1>{user.name}</h1>;
}

function App() {
  return (
    <Suspense fallback={<p>Loading user...</p>}>
      <Profile />
    </Suspense>
  );
}
```

**Note:** `use()` is part of experimental or server component features and not available in regular client-side hooks (yet).

---

## Suspense vs Traditional Loading

| Feature                         | Suspense | Traditional Loading (useEffect + isLoading) |
| ------------------------------- | -------- | ------------------------------------------- |
| Declarative                     | ✅ Yes   | ❌ No                                       |
| Integrated with React rendering | ✅ Yes   | ❌ No                                       |
| Reusable Fallback               | ✅ Yes   | ✅ Yes                                      |
| Requires throwing a promise     | ✅ Yes   | ❌ No                                       |

---

## Combined with Concurrent Features

Suspense works best with:

- **Concurrent Mode (enabled by default in React 18)**
- **React Server Components**
- **Streaming SSR (Server-Side Rendering)**
- **useTransition** for delaying non-urgent updates

```jsx
const [isPending, startTransition] = useTransition();

startTransition(() => {
  setValue(input); // Suspense can kick in if this causes re-render that fetches async data
});
```

---

## Common Interview Questions and Answers

### 1. What problem does Suspense solve?

Suspense abstracts away the boilerplate of manually handling loading states using `useState` and `useEffect`. It allows rendering to pause while asynchronous operations (like code or data fetching) complete, improving code readability and consistency.

### 2. Can you use Suspense with REST APIs?

By default, Suspense does not natively support REST APIs. However, it can be used with REST if wrapped in a custom abstraction that throws a promise (like a resource wrapper). Libraries like **React Query** provide this abstraction to integrate REST with Suspense.

### 3. How does Suspense improve UX over traditional loaders?

Suspense enables better **control over rendering timing**, **fallback placement**, and **consistency** of loading UIs. It avoids layout shifts and scattered loading flags by co-locating fallback UIs declaratively near the suspended component.

### 4. What libraries integrate Suspense for data fetching?

- **Relay (official support)**
- **React Query** (experimental support)
- **SWR** (future Suspense support)
- **React Server Components** (built-in suspense for async boundaries)

### 5. What happens if multiple components suspend at the same time?

If multiple nested components suspend simultaneously, React looks for the nearest common `<Suspense>` boundary to show its fallback. Once all promises resolve, it resumes rendering from that point. You can nest boundaries to isolate fallback UIs for different parts of the UI.

---

## Conclusion

React Suspense is a powerful abstraction for dealing with asynchronous operations declaratively. It simplifies loading states, integrates deeply with concurrent rendering, and is an essential tool for building modern, responsive, and maintainable React applications.

> 🎯 Mastery of Suspense is expected at the senior level, especially in conjunction with performance optimization, SSR, and concurrent features.

---

---

## 20. How has React 18 improved Suspense?

React 18 introduced significant improvements to Suspense to support **concurrent rendering** and **server-side streaming**, making asynchronous UI more powerful and seamless.

---

## Key Improvements in React 18 Suspense

### 1. **Concurrent Rendering Support**

React 18 enables Suspense to work with **concurrent rendering**, allowing the UI to remain responsive even during intensive asynchronous operations.

- **Before React 18**: Suspense only worked with `React.lazy()` for code-splitting.
- **With React 18**: Suspense can pause rendering for data fetching, image loading, and other async tasks.

> This enables smooth transitions and avoids layout shifts by pausing the render until everything is ready.

```jsx
<Suspense fallback={<Loading />}>
  <ProfilePage />
</Suspense>
```

### 2. **Streaming Server-Side Rendering (SSR)**

React 18 supports **streaming HTML responses from the server** using Suspense.

- Allows the server to send fallback content immediately while waiting for data.
- Enhances Time to First Byte (TTFB) and improves perceived performance.

```js
// Express + React 18 SSR
pipeToNodeWritable(<App />, res);
```

> The server can stream partially rendered HTML while waiting for other parts to load.

### 3. **`useTransition` Hook Integration**

`useTransition` enables marking parts of the UI as "non-urgent". Suspense can delay rendering these parts until ready.

```jsx
const [isPending, startTransition] = useTransition();

startTransition(() => {
  setSearchQuery(value); // Updates can suspend here
});
```

This keeps input or UI interactions smooth, even when parts of the UI suspend.

### 4. **Better Nesting and Fallback Control**

With React 18, nested Suspense boundaries behave more predictably:

- Only the boundary that suspends shows its fallback.
- You can nest multiple fallbacks for different levels of granularity.

```jsx
<Suspense fallback={<PageSkeleton />}>
  <Navbar />
  <Suspense fallback={<FeedSkeleton />}>
    <Feed />
  </Suspense>
</Suspense>
```

---

## Real Use Cases

- **Streaming SSR** for faster initial loads on slow networks
- **Improved UX for async-heavy UIs** (dashboards, content feeds)
- **Non-blocking transitions** for real-time filters/searches
- **Fine-grained fallbacks** for specific parts of the page

---

## Conclusion

React 18 has turned Suspense into a robust tool for handling async rendering across both client and server environments. With concurrent features, streaming SSR, and support for finer control, Suspense helps developers build faster, more responsive, and user-friendly applications.

> 🚀 For a senior developer, understanding and leveraging these Suspense features is essential for building modern React apps optimized for both performance and scalability.

---

---

## 21. What is the new `startTransition` function in React 18?

`startTransition()` is a new API introduced in **React 18** that allows developers to mark updates as **non-urgent**. These updates, known as **transitions**, tell React that the update can be interrupted and doesn't need to happen immediately.

It’s part of React’s **concurrent rendering** capabilities, designed to improve performance and responsiveness in modern applications.

---

## Why Do We Need It?

In traditional rendering, **all state updates are treated as urgent**, which can lead to janky UI when complex or slow renders block more immediate interactions like typing.

`startTransition()` solves this by letting React prioritize **urgent updates** (e.g., input field typing) over **non-urgent ones** (e.g., search result updates).

---

## Basic Syntax

```jsx
import { startTransition } from "react";

startTransition(() => {
  // Non-urgent update
  setState(newValue);
});
```

You can also use the `useTransition` hook:

```jsx
const [isPending, startTransition] = useTransition();

startTransition(() => {
  setFilteredData(expensiveComputation(input));
});
```

---

## Real-World Example

```jsx
function SearchComponent() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    startTransition(() => {
      const filtered = expensiveSearch(value);
      setResults(filtered);
    });
  };

  return (
    <div>
      <input type='text' value={query} onChange={handleChange} />
      {isPending && <p>Loading...</p>}
      <ul>
        {results.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```

### How it helps:

- Keeps typing snappy
- Defers expensive UI updates
- Renders fallback (`Loading...`) only if delay is noticeable

---

## Behavior Summary

| Feature                         | Behavior            |
| ------------------------------- | ------------------- |
| Interruptible                   | ✅ Yes              |
| Deferred priority               | ✅ Yes              |
| Keeps urgent updates responsive | ✅ Yes              |
| Causes fallback rendering       | ✅ Only when needed |
| Works with Suspense             | ✅ Yes              |

---

## When to Use `startTransition()`

- Filtering/searching large data sets
- Rendering tabs/pages with async content
- Deferring re-renders of heavy UI blocks
- Reducing jank during rapid user interaction

---

## Conclusion

React 18’s `startTransition()` provides developers with granular control over rendering priority, improving UX and responsiveness. It allows you to prioritize interactions like input and clicks while deferring expensive updates, unlocking the full power of **concurrent rendering** in modern React apps.

> 💡 Tip: Use `startTransition` thoughtfully — not all updates should be deferred. Only mark updates as transitions if deferring them improves user experience.

---

---

## 22. What is the difference between `useTransition` and `startTransition`?

React 18 introduced **Concurrent Features** to improve rendering performance. Two key APIs that support deferred, non-blocking updates are:

- `startTransition()` – a top-level function
- `useTransition()` – a React hook

These APIs serve similar purposes but are used in **different contexts**.

---

## 1. `startTransition()` – Top-Level API

### Description:

A global function from React that wraps **non-urgent updates** and tells React to schedule them with lower priority.

### Syntax:

```jsx
import { startTransition } from "react";

startTransition(() => {
  setState(newValue);
});
```

### Use Case:

- Used **outside of React components** or **inside event handlers** when hooks are not ideal
- Useful in **class components** or **utilities outside the render tree**

### Example:

```jsx
function handleInputChange(value) {
  startTransition(() => {
    setFilteredData(filterHeavyList(value));
  });
}
```

---

## 2. `useTransition()` – Hook API

### Description:

A React hook that returns a transition state (`isPending`) along with the `startTransition` function. Allows tracking if a transition is ongoing.

### Syntax:

```jsx
const [isPending, startTransition] = useTransition();
```

### Use Case:

- Ideal for usage **inside functional components**
- You can show a **loading indicator** during the transition

### Example:

```jsx
function SearchComponent() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    startTransition(() => {
      const filtered = heavySearch(value);
      setResults(filtered);
    });
  };

  return (
    <div>
      <input value={query} onChange={handleChange} />
      {isPending && <p>Loading...</p>}
      <ul>
        {results.map((r) => (
          <li key={r}>{r}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

## Summary Table

| Feature                         | `startTransition`          | `useTransition`              |
| ------------------------------- | -------------------------- | ---------------------------- |
| Type                            | Function                   | Hook                         |
| Usage Context                   | Anywhere (events, classes) | Inside functional components |
| Returns `isPending`?            | ❌ No                      | ✅ Yes                       |
| Ideal for Tracking UI State     | ❌ No                      | ✅ Yes                       |
| Works with Concurrent Rendering | ✅ Yes                     | ✅ Yes                       |

---

## Final Thoughts

Both `startTransition` and `useTransition` help prioritize urgent vs. non-urgent updates, enabling smoother and more responsive user experiences. For functional components, prefer `useTransition` to get loading state; use `startTransition` elsewhere to defer heavy updates.

> 🎯 Knowing when and where to use these APIs is critical for building performant apps and will be a key topic in senior React interviews.

---

---

## 23. How do you use the Concurrent Features introduced in React 18?

React 18 introduced **Concurrent Features** to enable smoother and more responsive user interfaces by making rendering interruptible and non-blocking. These features are foundational for performance optimizations and future capabilities like React Server Components.

---

## 🔧 What Are Concurrent Features?

**Concurrent rendering** allows React to work on multiple tasks at once, yielding to the browser when needed, and resuming work later. This results in a more fluid and less janky user experience.

Concurrent features include:

- `useTransition()` and `startTransition()`
- `useDeferredValue()`
- Automatic Batching
- Concurrent Rendering (enabled automatically)
- `Suspense` enhancements
- React Server Components (experimental)

---

## 🚀 Enabling Concurrent Features

Concurrent features are enabled **automatically in React 18** when using the new `createRoot()` API:

```jsx
import { createRoot } from "react-dom/client";
import App from "./App";

const container = document.getElementById("root");
const root = createRoot(container); // Enables concurrent features
root.render(<App />);
```

> ⚠️ Old `ReactDOM.render()` does not support concurrent features.

---

## ✅ 1. `useTransition()` and `startTransition()`

Used for **deferring non-urgent updates**, such as filtering large lists without blocking UI:

```jsx
const [isPending, startTransition] = useTransition();

startTransition(() => {
  setValue(expensiveCalculation(input));
});
```

### Benefits:

- Prevents UI freeze
- Better user feedback via `isPending`

---

## ✅ 2. `useDeferredValue()`

Useful for delaying the update of a value until the browser is ready:

```jsx
const deferredQuery = useDeferredValue(query);
```

### Use Case:

- Search suggestions that should only update after input stabilizes

---

## ✅ 3. Automatic Batching

Multiple state updates in the same event loop are batched automatically:

```jsx
setCount((c) => c + 1);
setFlag((f) => !f);
```

### Before React 18:

- These would trigger two renders

### In React 18:

- Batched into one render for performance

---

## ✅ 4. Improved Suspense for Data Fetching

React 18 improves `Suspense` for streaming SSR and asynchronous rendering. Combined with `React.lazy`, `Suspense` lets you declaratively show fallback UIs:

```jsx
<Suspense fallback={<Spinner />}>
  <MyComponent />
</Suspense>
```

---

## ✅ 5. Streaming Server-Side Rendering (SSR)

React 18 enables HTML streaming from the server with `renderToPipeableStream()` or `renderToReadableStream()`.

Benefits:

- Faster TTI (Time to Interactive)
- Incremental hydration

```js
// Node.js example with Express
pipeableStream = renderToPipeableStream(<App />, options);
pipeableStream.pipe(res);
```

---

## 🧪 6. React Server Components (Experimental)

Server-rendered components that do not add to the JS bundle. Ideal for data fetching or logic-heavy components.

```jsx
// .server.jsx file
export default function ServerComponent() {
  const data = fetchDataFromDB();
  return <div>{data}</div>;
}
```

---

## Summary Table

| Feature            | Purpose                                | Use Case                      |
| ------------------ | -------------------------------------- | ----------------------------- |
| `useTransition`    | Defer state updates                    | Autocomplete, filtering lists |
| `useDeferredValue` | Delay rendering of a value             | Lazy-updating search results  |
| Automatic Batching | Batch multiple updates into one render | Performance boost             |
| `Suspense`         | Show fallback during async rendering   | Lazy-loaded components, data  |
| Server Components  | Run code on server only                | Reduce bundle size            |

---

## Final Thoughts

Understanding and leveraging **Concurrent Features** is crucial for building **fast, responsive, and scalable** React applications. Mastery of these features is expected at the senior level, especially in apps with heavy rendering logic, dynamic UIs, and complex async workflows.

> 💡 Bonus: Try combining `useTransition`, `Suspense`, and streaming SSR for maximum performance in modern apps!

---

---

## 24. How does React 18 enhance server-side rendering (SSR)?

React 18 introduced major improvements to server-side rendering (SSR), aligning with its concurrent features and enabling more scalable, interactive, and faster-loading web applications.

These enhancements address performance, streaming capabilities, and better developer ergonomics for rendering React components on the server.

---

## 🔑 Key Enhancements in React 18 SSR

### 1. **Streaming HTML with `renderToPipeableStream`**

Instead of waiting for the entire React tree to be rendered before sending it to the client, React 18 can stream HTML as it's generated.

```js
import { renderToPipeableStream } from "react-dom/server";

const stream = renderToPipeableStream(<App />, {
  onShellReady() {
    stream.pipe(response);
  },
  onError(err) {
    console.error(err);
  },
});
```

#### Benefits:

- First chunks are sent immediately (faster Time to First Byte - TTFB)
- JavaScript hydration can happen progressively
- Reduces server memory usage

---

### 2. **Selective Hydration**

React 18 enables hydration to be **prioritized and selective**, based on what users interact with first. This enhances responsiveness.

#### Example:

When a user clicks a button in a partially hydrated app, React hydrates that component first.

```js
// React hydrates the part of UI that gets interacted with first
```

#### Benefits:

- Faster initial interactions
- Improved performance on slower devices/networks

---

### 3. **Concurrent SSR with `Suspense`**

`<Suspense>` now works on the server, allowing components to "wait" for async data during SSR and stream out the rest of the content.

```jsx
<Suspense fallback={<Loading />}>
  <DataComponent />
</Suspense>
```

#### Benefits:

- Improved user experience during data fetching
- Ability to start streaming immediately and fill in placeholders as data loads

---

### 4. **Better Error Handling and Streaming Timeouts**

React 18's SSR APIs allow fine-grained control over what to stream, fallback UIs, and how to handle streaming errors/timeouts.

```js
renderToPipeableStream(<App />, {
  onShellError(err) {
    res.status(500).send("Something went wrong");
  },
  onAllReady() {
    // All content including Suspense boundaries are ready
  },
});
```

---

### 5. **React Server Components (RSC) – Experimental**

React 18 introduces support for Server Components, which render on the server **without sending their JS to the client**.

- Server Components + SSR = highly optimized performance
- Still experimental, but it plays a critical role in the future of SSR in React

---

## Summary Table

| Feature                 | Before React 18       | React 18                      |
| ----------------------- | --------------------- | ----------------------------- |
| Streaming               | ❌ Full HTML blocking | ✅ Streamed HTML output       |
| Suspense on Server      | ❌ No                 | ✅ Yes                        |
| Selective Hydration     | ❌ No                 | ✅ Yes                        |
| Pipeable Streams        | ❌ No                 | ✅ `renderToPipeableStream()` |
| React Server Components | ❌ No                 | 🧪 Experimental support       |

---

## Conclusion

React 18 dramatically improves the SSR experience by enabling streaming, Suspense on the server, selective hydration, and better control over server rendering flows. These changes lay the groundwork for more scalable and performant React applications—especially for teams building with SSR, static generation, and serverless architecture in mind.

> 🚀 Understanding and utilizing these SSR features is key for senior React developers working on high-performance, production-grade applications.

---

---

## 25. What is React Server Components, and how does it work with React 18?

**React Server Components (RSC)** are a new type of React component that render exclusively on the **server**, never shipping their code to the **client**. Introduced experimentally and evolving with **React 18**, they aim to improve performance by reducing the JavaScript bundle size and enabling better server-side logic handling.

### 🔑 Key Characteristics:

- Rendered only on the server
- No impact on client bundle size
- Can fetch data directly from databases or APIs
- Seamlessly integrate with client components

---

## ⚙️ How Do Server Components Work?

Server Components are written like regular React components but executed on the server. When requested by the client, they are rendered server-side into a special serialized format and streamed to the browser, where React assembles them into the DOM.

### 🔄 Component Flow

1. **Server Component** fetches data or renders markup.
2. React serializes the output into a stream.
3. The client receives the stream and stitches it into the React tree.
4. Client Components hydrate normally where necessary.

### 🧠 Example:

```jsx
// Server Component (server only)
export default function ProductList() {
  const products = await db.getProducts(); // server-side DB call
  return (
    <ul>
      {products.map(p => <li key={p.id}>{p.name}</li>)}
    </ul>
  );
}
```

```jsx
// Client Component (with interactivity)
"use client";

export default function AddToCartButton({ productId }) {
  return <button onClick={() => addToCart(productId)}>Add to Cart</button>;
}
```

You can **mix** Server and Client Components by importing Client Components into Server Components, but **not the other way around**.

---

## 🧩 Server + Client Integration

React Server Components enable splitting your app into three logical parts:

- **Server Components**: for heavy lifting and data fetching
- **Client Components**: for interactive UI
- **Shared Components**: reusable between both

```jsx
// Server Component imports Client
import AddToCartButton from "./AddToCartButton";

function ProductCard({ product }) {
  return (
    <div>
      <h2>{product.name}</h2>
      <AddToCartButton productId={product.id} />
    </div>
  );
}
```

---

## ⚒️ React 18 & RSC Support

React 18 includes **experimental support** for Server Components. Full integration is expected via frameworks like **Next.js 13+**, which provides structured file-based routing with:

- `app/` directory
- `page.js`, `layout.js` (Server Components by default)
- `use client` directive for client interactivity

### Example with Next.js:

```bash
/app
  /page.js        --> Server Component
  /Search.js      --> Server Component
  /Button.js      --> Client Component (contains 'use client')
```

---

## 🧠 Why Use Server Components?

| Benefit           | Description                                            |
| ----------------- | ------------------------------------------------------ |
| 🚫 No client JS   | Components don't increase client JS bundle size        |
| ⚡ Faster Loads   | Less JS = faster TTI (Time to Interactive)             |
| 🔐 Secure Data    | Data never exposed to the browser                      |
| 🔁 Integrated SSR | Plays well with streaming and Suspense                 |
| 🎯 Better DX      | More efficient data fetching co-located with rendering |

---

## 🧪 Limitations & Considerations

- Still **experimental**: not stable for all production use cases
- Cannot use React state or effects inside Server Components
- Client-only packages (e.g., `window`, `localStorage`) are not available
- Requires a framework (e.g., Next.js) to handle routing and streaming

---

## 📌 Conclusion

React Server Components offer a paradigm shift in building web applications. They optimize performance by reducing client-side JavaScript and co-locating data fetching with rendering logic. When combined with React 18 features like **Suspense** and **streaming**, RSCs unlock new levels of scalability and developer productivity.

> As a senior React developer, understanding RSC is crucial for architecting performant and scalable frontend solutions in modern web applications.

---

---

## 26. What role does the `concurrentMode` flag play in React 18?

In React 18, **Concurrent Mode** is no longer something that needs to be explicitly enabled with a special flag like it did in earlier versions. Instead, React 18 introduces **Concurrent Features** that are opt-in by using specific APIs such as `startTransition`, `useTransition`, `Suspense`, and `useDeferredValue`.

React 18 is **concurrent by default** for updates handled through the new root API (`createRoot`), but it doesn't enable full concurrent rendering unless you opt into those APIs. This gives developers **granular control** over which parts of the app should behave concurrently.

---

## Key Concepts of Concurrent Mode

### 1. **Time-Slicing**

Concurrent Mode breaks rendering work into chunks and spreads it out over multiple frames. This makes your app more **responsive**, especially during heavy renders or slow network conditions.

### 2. **Interruptible Rendering**

React can pause the rendering work of one update to prioritize a more urgent one (like responding to user input), improving the **UX responsiveness**.

### 3. **Prioritized Updates**

With APIs like `startTransition`, developers can mark certain updates as "non-urgent" so that React can continue responding to user interactions without delay.

---

## Enabling Concurrent Features

### React 18 `createRoot` API

```jsx
import { createRoot } from "react-dom/client";
import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

> Using `createRoot` instead of `ReactDOM.render` enables concurrent rendering capabilities.

### Example: Using `startTransition`

```jsx
import { startTransition, useState } from "react";

function App() {
  const [query, setQuery] = useState("");

  const handleChange = (e) => {
    const value = e.target.value;
    startTransition(() => {
      setQuery(value); // Low-priority update
    });
  };

  return <input onChange={handleChange} value={query} />;
}
```

---

## Comparison: Legacy vs Concurrent

| Feature              | Legacy Mode               | Concurrent Mode           |
| -------------------- | ------------------------- | ------------------------- |
| Updates are          | Blocking                  | Interruptible             |
| Input responsiveness | Can lag during re-renders | Always responsive         |
| Update priority      | Uniform                   | Granular with transitions |

---

## Why Was `concurrentMode` Flag Removed?

In previous experimental versions of React, you had to wrap the root in `<ConcurrentMode>` or enable a flag to opt into this behavior. React 18 changed this with the idea of **incremental adoption**:

- Concurrent behavior is **enabled per root** with `createRoot()`.
- Full concurrent rendering only kicks in **when you use a concurrent feature** like `startTransition`, `Suspense`, or `useDeferredValue`.

This approach helps avoid unexpected breaking changes and gives you **control over performance optimization**.

---

## Conclusion

The `concurrentMode` flag as an explicit wrapper is no longer needed in React 18. Instead, React enables concurrent capabilities through its new root API and specific hooks that you opt into. Understanding and correctly using these APIs is **crucial for building responsive, modern applications**, especially at a senior developer level.

> 🚀 Mastery of concurrent features is a key expectation for React engineers in 2024 and beyond.

---

---

## 27. Explain the React lifecycle methods in detail.

React components go through a well-defined **lifecycle** from their creation to unmounting. Understanding these lifecycle methods is crucial, especially for class components (though hooks are the modern alternative).

## Lifecycle Phases

React lifecycle can be broken into **three main phases**:

1. **Mounting** – when the component is being inserted into the DOM.
2. **Updating** – when the component is being re-rendered due to changes in props or state.
3. **Unmounting** – when the component is being removed from the DOM.

---

## 1. Mounting Phase

These methods are called in order when an instance of a component is being created and inserted into the DOM.

### `constructor(props)`

- Initializes state and binds methods.
- Avoid heavy logic here.

```jsx
constructor(props) {
  super(props);
  this.state = { count: 0 };
}
```

### `static getDerivedStateFromProps(props, state)`

- Rarely used.
- Syncs state from props before render.
- Must return new state or `null`.

```jsx
static getDerivedStateFromProps(nextProps, prevState) {
  if (nextProps.value !== prevState.value) {
    return { value: nextProps.value };
  }
  return null;
}
```

### `render()`

- Returns the JSX to render.
- Pure function: No side effects.

```jsx
render() {
  return <div>{this.state.count}</div>;
}
```

### `componentDidMount()`

- Invoked after the component is mounted.
- Ideal for data fetching, subscriptions.

```jsx
componentDidMount() {
  fetch('/api/data').then(res => res.json()).then(data => this.setState({ data }));
}
```

---

## 2. Updating Phase

Called when props or state change.

### `static getDerivedStateFromProps()`

- Also called here if component is re-rendering due to props.

### `shouldComponentUpdate(nextProps, nextState)`

- Allows performance optimization.
- Return `false` to skip render.

```jsx
shouldComponentUpdate(nextProps, nextState) {
  return nextState.count !== this.state.count;
}
```

### `render()`

- Called again to update the DOM.

### `getSnapshotBeforeUpdate(prevProps, prevState)`

- Rarely used.
- Captures info (like scroll position) **before** the update.
- Value is passed to `componentDidUpdate`.

```jsx
getSnapshotBeforeUpdate(prevProps, prevState) {
  return window.scrollY;
}
```

### `componentDidUpdate(prevProps, prevState, snapshot)`

- Called after update is flushed to DOM.
- Good for side effects after updates.

```jsx
componentDidUpdate(prevProps, prevState, snapshot) {
  if (snapshot !== null) {
    window.scrollTo(0, snapshot);
  }
}
```

---

## 3. Unmounting Phase

### `componentWillUnmount()`

- Cleanup tasks like cancelling API calls, clearing timers.

```jsx
componentWillUnmount() {
  clearInterval(this.timer);
}
```

---

## Error Handling Phase

### `componentDidCatch(error, info)`

- Catches rendering errors in child components.
- Used in error boundaries.

```jsx
componentDidCatch(error, info) {
  logErrorToService(error, info);
}
```

### `static getDerivedStateFromError(error)`

- Update state to show fallback UI on error.

```jsx
static getDerivedStateFromError(error) {
  return { hasError: true };
}
```

---

## Modern React: Lifecycle Equivalents with Hooks

While class components use lifecycle methods, function components use **hooks**.

| Lifecycle            | Hook Equivalent                               |
| -------------------- | --------------------------------------------- |
| componentDidMount    | useEffect(() => { ... }, [])                  |
| componentDidUpdate   | useEffect(() => { ... }, [dependencies])      |
| componentWillUnmount | useEffect(() => { return () => { ... } }, []) |

---

## Summary Table

| Phase          | Method                   | Purpose                        |
| -------------- | ------------------------ | ------------------------------ |
| Mounting       | constructor              | Initialize state               |
|                | getDerivedStateFromProps | Sync state from props          |
|                | render                   | Return JSX                     |
|                | componentDidMount        | DOM access, fetch data         |
| Updating       | shouldComponentUpdate    | Prevent unnecessary re-renders |
|                | getSnapshotBeforeUpdate  | Capture values before update   |
|                | componentDidUpdate       | Side effects after update      |
| Unmounting     | componentWillUnmount     | Cleanup                        |
| Error Handling | componentDidCatch        | Catch errors                   |
|                | getDerivedStateFromError | Show fallback UI               |

---

## Conclusion

Understanding React lifecycle methods is essential, especially when dealing with legacy codebases or performance-sensitive applications. Mastery of both class-based lifecycle methods and their functional hook equivalents is expected at a senior React level.

---

---

## 28. What is React Context API, and when would you use it?

The **React Context API** is a feature introduced in React 16.3 that allows for **global state management** by enabling components to share values without explicitly passing props through every level of the component tree (also known as "prop drilling").

It is especially useful for managing **theme data, user authentication, locale settings**, or any other state that needs to be accessible by many components at different levels.

---

## When Would You Use React Context API?

You should consider using Context API when:

- Props are being passed through **many nested components** (deep prop drilling).
- Multiple components need **access to the same data or logic** (e.g., authentication, theming, language settings).
- You want to **avoid external libraries** like Redux for lighter state-sharing needs.

> ⚠️ Context is not meant to replace all state management; it works best for app-wide state or low-frequency updates.

---

## Basic Structure of Context API

### 1. **Create Context**

```jsx
import React from "react";

const ThemeContext = React.createContext();
```

### 2. **Provide Context**

```jsx
function ThemeProvider({ children }) {
  const [theme, setTheme] = React.useState("dark");

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}
```

### 3. **Consume Context**

#### Using `useContext` (Function Component)

```jsx
import { useContext } from "react";

function ThemeToggler() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <button onClick={() => setTheme(theme === "dark" ? "light" : "dark")}>
      Current Theme: {theme}
    </button>
  );
}
```

#### Using `Context.Consumer` (Class Component)

```jsx
<ThemeContext.Consumer>
  {({ theme, setTheme }) => (
    <button onClick={() => setTheme(theme === "dark" ? "light" : "dark")}>
      {theme}
    </button>
  )}
</ThemeContext.Consumer>
```

---

## Best Practices

- **Avoid frequent updates** to context values, as it causes **re-renders in all consuming components**.
- Consider **splitting context** into multiple contexts for granular updates.
- Use **memoization** to optimize context values.
- Do not use Context API for complex state logic — consider Redux or Zustand for that.

---

## Real-World Use Cases

- **User Authentication** (e.g., AuthContext)
- **Theme Switching** (e.g., ThemeContext)
- **i18n Localization** (e.g., LocaleContext)
- **Feature Flags** or **Application Configs**

---

## Conclusion

The React Context API is a powerful built-in mechanism for sharing global data in a clean and scalable way. As a senior React developer, knowing when and how to use it — and its limitations — is crucial for designing maintainable applications.

---

**Example:**

```jsx
const ThemeContext = React.createContext("light");
```

---

## 29. What are higher-order components (HOCs) in React?

A **Higher-Order Component (HOC)** is an advanced React pattern used to **reusably add behavior or logic to components**. It is a **function** that takes a component and returns a new component with enhanced capabilities.

> HOC is essentially a **pure function** that doesn't modify the original component but instead returns a new one.

```js
const withLogger = (WrappedComponent) => {
  return function EnhancedComponent(props) {
    console.log("Props:", props);
    return <WrappedComponent {...props} />;
  };
};
```

## Syntax

```js
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```

## Why Use HOCs?

- **Code reuse**
- **Separation of concerns**
- **Cross-cutting logic** like logging, authentication, error handling, etc.

## Real-World Examples

### 1. Adding Logging

```js
function withLogging(WrappedComponent) {
  return function (props) {
    console.log(`Rendering ${WrappedComponent.name} with`, props);
    return <WrappedComponent {...props} />;
  };
}

const LoggedButton = withLogging(Button);
```

### 2. Authentication Guard

```js
function withAuthGuard(WrappedComponent) {
  return function (props) {
    if (!props.user) {
      return <Redirect to='/login' />;
    }
    return <WrappedComponent {...props} />;
  };
}

const ProtectedDashboard = withAuthGuard(Dashboard);
```

## Characteristics

- HOCs **do not modify** the original component.
- They can **wrap any number** of components.
- HOCs **should not copy static methods** — use `hoist-non-react-statics` to retain them if needed.

## Caveats

- **Ref forwarding** needs special handling using `React.forwardRef`.
- Can **increase complexity** when overused or deeply nested.
- **Debugging** can be harder as component trees become deeper.

## Comparison with Other Patterns

| Pattern      | Description                                          |
| ------------ | ---------------------------------------------------- |
| HOC          | Wraps component to enhance it                        |
| Render Props | Passes a function as a prop to decide what to render |
| Hooks        | Share logic without wrapping components              |

## When to Use HOCs

- When you need to **enhance components** without modifying them directly.
- For **cross-cutting concerns** like logging, theming, access control.
- When **hooks can't be used** (e.g., class components).

---

## Summary

Higher-Order Components (HOCs) are a key abstraction in React for creating reusable, composable logic across components. While React Hooks have become the preferred approach in modern apps, understanding HOCs is essential for maintaining older codebases and performing advanced architectural patterns.

---

---

## 30. How does React handle forms and controlled components?

Controlled components have their value controlled by state.

**Example:**

```jsx
function Form() {
  const [value, setValue] = useState("");
  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}
```

---

## 31. What are uncontrolled components in React?

Uncontrolled components rely on refs instead of state to manage their value.

---

## 32. What is Prop Drilling, and how can it be avoided?

Prop drilling occurs when data is passed through multiple layers of components. It can be avoided using Context API or state management libraries.

---

## 33. What are React Portals, and when should you use them?

Portals render children into a DOM node outside the parent component.

**Example:**

```jsx
ReactDOM.createPortal(child, container);
```

---

## 34. What is the significance of React’s `shouldComponentUpdate` method?

`shouldComponentUpdate` improves performance by preventing unnecessary re-renders.

---

## 35. What are Fragments in React?

Fragments allow grouping of elements without adding extra nodes to the DOM.

**Example:**

```jsx
<>
  <h1>Hello</h1>
  <p>World</p>
</>
```

---

## 36. Explain the concept of memoization in React using `React.memo` and `useMemo`.

- `React.memo`: Prevents re-rendering of functional components unless props change.
- `useMemo`: Memoizes the result of a computation.

---

## 37. How Do You Optimize Performance in a React Application?

1. Use `React.memo` to avoid unnecessary re-renders.
2. Use `useMemo` and `useCallback` for expensive computations and function references.
3. Avoid inline functions in props.
4. Split code using lazy loading and `React.Suspense`.
5. Enable production build for performance optimizations.
6. Use tools like React Developer Tools Profiler.

---

## 38. Rules for Using React Hooks

1. **Call Hooks at the Top Level**: Don’t use hooks inside loops, conditions, or nested functions.
2. **Only Call Hooks from React Functions**: They can only be used in functional components or custom hooks.
3. **Follow Naming Convention**: Always start custom hooks with `use`.

---

## 39. Handling Errors in React Using Error Boundaries

Error boundaries are React components that catch JavaScript errors in their child components and render a fallback UI instead of crashing the whole app.

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error("Error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

---

## 40. `componentDidCatch` Method

Used in class components to handle errors in child components and log them.

```jsx
componentDidCatch(error, errorInfo) {
  console.error("Logged Error:", error, errorInfo);
}
```

---

## 41. Synthetic Events in React

Synthetic events are a cross-browser wrapper around native events in React.

```jsx
function handleClick(e) {
  e.preventDefault();
  console.log("Button clicked!");
}
```

---

## 42. Testing React Components

Use tools like Jest and React Testing Library.

```jsx
import { render, screen } from "@testing-library/react";
import App from "./App";

test("renders learn react link", () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

---

## 43. Role of Jest in React Testing

Jest is a testing framework used for unit and integration testing in React.

---

## 44. Shallow Rendering vs. Full Rendering

- **Shallow Rendering**: Tests components in isolation without rendering children.
- **Full Rendering**: Renders children components for integration tests.

---

## 45. Implementing Lazy Loading in React

Use `React.lazy` and `Suspense`.

```jsx
import React, { Suspense } from "react";

const LazyComponent = React.lazy(() => import("./LazyComponent"));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

---

## React Working Mechanism

React uses a Virtual DOM to track changes and efficiently update the Real DOM by comparing diffs (reconciliation).

---

## Higher Order Component (HOC) Example

HOCs are functions that take a component and return a new one.

```jsx
function withLogger(Component) {
  return function EnhancedComponent(props) {
    console.log("Rendering", Component.name);
    return <Component {...props} />;
  };
}
```

---

## Pure Component Example

Pure components only re-render when their props or state change.

```jsx
import React, { PureComponent } from "react";

class MyComponent extends PureComponent {
  render() {
    return <div>{this.props.text}</div>;
  }
}
```

---

## Controlled vs. Uncontrolled Components

- **Controlled**: State is managed by React.
- **Uncontrolled**: State is managed by the DOM.

**Controlled Example**:

```jsx
function ControlledInput() {
  const [value, setValue] = useState("");

  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}
```

**Uncontrolled Example**:

```jsx
function UncontrolledInput() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(inputRef.current.value);
  };

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}
```

---

### 46. What are PropTypes in React?

PropTypes is a type-checking feature in React that ensures components receive props of the correct data type. It helps identify bugs by validating the types of props passed to components.

```jsx
import PropTypes from "prop-types";

const Greeting = ({ name, age }) => (
  <div>
    <h1>Hello, {name}!</h1>
    <p>Age: {age}</p>
  </div>
);

Greeting.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
};
```

### 47. What is Redux, and how is it used in React?

Redux is a state management library that provides a centralized store for managing application state. It works well with React by using the `react-redux` library to connect the Redux store to React components.

#### Key Concepts of Redux:

- **Store**: Holds the entire state of the application.
- **Actions**: Describes the changes you want to make to the state.
- **Reducers**: Specifies how the state changes in response to actions.

Example:

```jsx
// actions.js
export const increment = () => ({ type: "INCREMENT" });

// reducer.js
const initialState = { count: 0 };
export const counterReducer = (state = initialState, action) => {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, count: state.count + 1 };
    default:
      return state;
  }
};

// App.js
import { createStore } from "redux";
import { Provider } from "react-redux";
import { counterReducer } from "./reducer";

const store = createStore(counterReducer);

const App = () => (
  <Provider store={store}>
    <Counter />
  </Provider>
);
```

### 48. What is the difference between Context API and Redux?

| Feature          | Context API              | Redux                        |
| ---------------- | ------------------------ | ---------------------------- |
| Purpose          | Simplifies state sharing | Centralized state management |
| Use Case         | Localized state sharing  | Complex state management     |
| Boilerplate Code | Minimal                  | Requires setup               |
| Middleware       | Not supported            | Supported                    |

### 49. How do you handle side effects in Redux?

Side effects in Redux, such as API calls, can be handled using middleware like `redux-thunk` or `redux-saga`.

#### Example with redux-thunk:

```jsx
// actions.js
export const fetchData = () => async (dispatch) => {
  const response = await fetch("/api/data");
  const data = await response.json();
  dispatch({ type: "FETCH_SUCCESS", payload: data });
};
```

### 50. What is the difference between React.memo and useMemo?

| Feature | React.memo                                | useMemo                                                   |
| ------- | ----------------------------------------- | --------------------------------------------------------- |
| Purpose | Memoizes a component to avoid re-renders  | Memoizes a value or computation                           |
| Usage   | Wrapping components                       | Inside functional components                              |
| Example | `export default React.memo(MyComponent);` | `const memoizedValue = useMemo(() => compute(), [deps]);` |

### 51. What is the difference between useCallback and useMemo?

| Feature      | useCallback               | useMemo                         |
| ------------ | ------------------------- | ------------------------------- |
| Purpose      | Memoizes functions        | Memoizes values or computations |
| Return Value | Returns memoized function | Returns memoized value          |

### 52. What is React Fiber?

React Fiber is the underlying algorithm in React that allows incremental rendering. It improves rendering performance and enables features like Suspense and Concurrent Mode.

### 53. How does hydration work in React?

Hydration is the process of attaching event listeners to the DOM elements rendered by React on the server. It is used in server-side rendering (SSR) to make the app interactive.

### 54. What are static methods in React components?

Static methods are methods declared with the `static` keyword that belong to the class, not its instances. These are often used for defining helper functions.

```jsx
class MyComponent extends React.Component {
  static displayName = "MyComponent";

  static greet() {
    return "Hello!";
  }
}

console.log(MyComponent.greet()); // Hello!
```

### 55. What are the best practices for structuring a React application?

- Use **functional components** over class components.
- Maintain a **clear folder structure**.
- Use **PropTypes** or TypeScript for type checking.
- Optimize performance with **React.memo** and **lazy loading**.
- Centralize state management with **Context API** or **Redux**.
- Keep components **small and reusable**.

### 56. What is the difference between useEffect and useLayoutEffect?

| Feature        | useEffect                 | useLayoutEffect               |
| -------------- | ------------------------- | ----------------------------- |
| Execution Time | After rendering           | Before painting to the screen |
| Use Case       | Non-blocking side effects | Blocking updates to the DOM   |

### 57. How does React handle updates to child components?

React updates child components when:

- Their **props** change.
- Their **state** changes.
- A **parent re-renders** unless optimized with `React.memo` or `shouldComponentUpdate`.

### 58. What is StrictMode in React?

StrictMode is a development-only feature that highlights potential problems in an application.

Example:

```jsx
<React.StrictMode>
  <App />
</React.StrictMode>
```

### 59. How do you create a reusable modal in React?

```jsx
const Modal = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;

  return (
    <div className='modal-backdrop'>
      <div className='modal-content'>
        {children}
        <button onClick={onClose}>Close</button>
      </div>
    </div>
  );
};
```

### 60. How does React handle accessibility?

React supports accessibility standards by using:

- Semantic HTML.
- ARIA attributes like `role`, `aria-label`.
- Tools like `eslint-plugin-jsx-a11y`.

## Advanced Topics

### 61. What is a render prop in React?

A render prop is a technique for sharing code between components using a prop whose value is a function.

```jsx
const MouseTracker = ({ render }) => {
  const [position, setPosition] = React.useState({ x: 0, y: 0 });

  const handleMouseMove = (event) => {
    setPosition({ x: event.clientX, y: event.clientY });
  };

  return <div onMouseMove={handleMouseMove}>{render(position)}</div>;
};
```

### 62. How does React handle animations?

React handles animations using libraries like:

- **CSS Transitions**: Use `className` changes.
- **React Transition Group**: For managing animations on component mount/unmount.
- **Framer Motion**: For advanced animations.

### 63. What is the useImperativeHandle hook?

`useImperativeHandle` customizes the instance value exposed when using `React.forwardRef`.

Example:

```jsx
const CustomInput = React.forwardRef((props, ref) => {
  const inputRef = React.useRef();

  React.useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
  }));

  return <input ref={inputRef} {...props} />;
});
```

---

### 1. **What is the difference between `React.createElement` and JSX?**

`React.createElement` is a method used to create and return a React element. JSX is a syntactic sugar for `React.createElement` and makes the code more readable and expressive.

#### Example:

```jsx
// Using React.createElement
const element = React.createElement(
  "h1",
  { className: "title" },
  "Hello, React!"
);

// Using JSX
const element = <h1 className='title'>Hello, React!</h1>;
```

### 2. **What is reconciliation in React?**

Reconciliation is the process by which React updates the DOM efficiently. It compares the new Virtual DOM with the previous one and calculates the minimal set of changes needed to update the actual DOM.

### 3. **What is the difference between `useRef` and `createRef`?**

- `createRef` is used in class components to create a reference to an element.
- `useRef` is used in functional components to persist a mutable reference across renders without causing re-renders.

#### Example:

```jsx
// Using useRef in a functional component
function App() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </>
  );
}

// Using createRef in a class component
class App extends React.Component {
  constructor() {
    super();
    this.inputRef = React.createRef();
  }

  focusInput = () => {
    this.inputRef.current.focus();
  };

  render() {
    return (
      <>
        <input ref={this.inputRef} />
        <button onClick={this.focusInput}>Focus Input</button>
      </>
    );
  }
}
```

### 4. **What are default props in React?**

Default props are used to define default values for props when they are not provided by the parent component.

#### Example:

```jsx
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}

Greeting.defaultProps = {
  name: "Guest",
};

<Greeting />; // Outputs: Hello, Guest!
```

### 5. **What are controlled and uncontrolled inputs in forms?**

- **Controlled Inputs:** React state controls the input value. The value of the input element is determined by the state.
- **Uncontrolled Inputs:** The input element manages its own state internally without React state.

#### Example:

```jsx
// Controlled Input
function ControlledInput() {
  const [value, setValue] = useState("");

  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}

// Uncontrolled Input
function UncontrolledInput() {
  const inputRef = useRef(null);

  const handleSubmit = () => {
    alert(inputRef.current.value);
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </>
  );
}
```

### 6. **What is the `key` prop in React, and why is it important?**

The `key` prop is a unique identifier used by React to track and identify components during reconciliation. It helps optimize rendering by updating only the necessary components.

#### Example:

```jsx
const items = ["Apple", "Banana", "Cherry"];

const list = items.map((item, index) => <li key={index}>{item}</li>);
```

### 7. **What is the difference between `React.Fragment` and `<></>`?**

Both are used to group multiple elements without adding extra nodes to the DOM. The shorthand syntax (`<>...</>`) is more concise but does not support key attributes.

#### Example:

```jsx
// Using React.Fragment
<React.Fragment>
  <h1>Title</h1>
  <p>Subtitle</p>
</React.Fragment>

// Using shorthand
<>
  <h1>Title</h1>
  <p>Subtitle</p>
</>
```

### 8. **What are React's new features in React 19?**

React 19 introduces several improvements (hypothetical future features):

- Enhanced Concurrent Rendering
- Native Suspense with improved data fetching
- Native TypeScript support

### 9. **What is the difference between `useMemo` and `React.memo`?**

- `useMemo`: Optimizes performance by memoizing values in functional components.
- `React.memo`: Prevents re-renders of a component if its props have not changed.

#### Example:

```jsx
// Using useMemo
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

// Using React.memo
const MemoizedComponent = React.memo(MyComponent);
```

### 10. **How does the React working mechanism function?**

React follows a declarative model and uses the Virtual DOM for efficient rendering. When a state or prop changes:

1. React creates a new Virtual DOM.
2. It compares the new Virtual DOM with the previous one (diffing).
3. React calculates the minimal updates and applies them to the actual DOM (reconciliation).

---
